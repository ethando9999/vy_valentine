<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Morphing Valentine</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        /* --- CẤU HÌNH CƠ BẢN --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            overflow: hidden;
            height: 100vh;
            font-family: 'Share Tech Mono', monospace;
            color: #fff;
            user-select: none;
        }

        /* Canvas vẽ hiệu ứng (Matrix + Particles) */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Nút Click me overlay */
        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            text-align: center;
            pointer-events: none; /* Để click xuyên qua canvas */
        }

        /* Chỉ hiển thị hướng dẫn lúc đầu */
        #hint-text {
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            letter-spacing: 2px;
            margin-top: 250px; /* Cách xa trái tim một chút */
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>

    <canvas id="mainCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="hint-text">[ CLICK VÀO TRÁI TIM ĐỂ BẮT ĐẦU ]</div>
    </div>

    <!-- Canvas ảo để quét text thành tọa độ hạt -->
    <canvas id="bufferCanvas" style="display:none;"></canvas>

    <script>
        // --- 1. CẤU HÌNH CHUNG ---
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const bufferCanvas = document.getElementById('bufferCanvas');
        const bufferCtx = bufferCanvas.getContext('2d');
        const uiHint = document.getElementById('hint-text');

        let width, height;
        let particles = [];
        const PARTICLE_COUNT = 1500; // Số lượng mảnh vỡ (hạt)
        const PHRASES = [
            "Happy Valentine 14/02",
            "Chúc nhóc valentine vui vẻ",
            "Chị yêu em nhất trên đời",
            "Hãy luôn bên cạnh chị nhé",
            "Là người tuyệt vời nhất",
            "Chúc em luôn hạnh phúc",
            "❤ YÊU EM ❤"
        ];

        // Trạng thái Animation
        let state = 'WAITING'; // WAITING, EXPLODING, HOVERING, FORMING, HOLDING
        let currentPhraseIndex = 0;

        // Cập nhật ký tự theo yêu cầu thành danh sách
        const matrixChars = ['TườngVy❤HoàngKiên'];
        
        // Cấu trúc dữ liệu cho Matrix Drops
        // Mỗi phần tử sẽ là object: { y: number, text: string, color: string, drawIndex: number }
        let matrixColumns = []; 

        // --- CẤU HÌNH TỐC ĐỘ MATRIX ---
        // Định nghĩa tốc độ rơi là 1200 pixel/giây
        // Với màn hình 60Hz (60 khung hình/giây), mỗi khung hình ký tự sẽ rơi: 1200 / 60 = 20 pixel
        const DROP_SPEED = 1200; 
        const FONT_SIZE = 20; // Kích thước font cũng là khoảng cách bước nhảy (20px)

        // --- 2. HỆ THỐNG HẠT (PARTICLE SYSTEM) ---

        class Particle {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.originX = this.x;
                this.originY = this.y;
                this.targetX = this.x;
                this.targetY = this.y;
                
                this.vx = 0;
                this.vy = 0;
                this.size = Math.random() * 2 + 1;
                this.color = '#fff';
                this.friction = 0.95;
                this.ease = 0.1; // Tốc độ bay về target
            }

            // Di chuyển về target
            update() {
                // Logic dựa trên trạng thái
                if (state === 'EXPLODING') {
                    // Bay tự do theo vận tốc
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= this.friction;
                    this.vy *= this.friction;
                } 
                else if (state === 'HOVERING') {
                    // Trôi nhẹ (Noise movement)
                    this.x += Math.sin(Date.now() * 0.001 + this.originX) * 0.5;
                    this.y += Math.cos(Date.now() * 0.001 + this.originY) * 0.5;
                }
                else if (state === 'FORMING' || state === 'HOLDING' || state === 'WAITING') {
                    // Bay về đích (Easing)
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    this.x += dx * this.ease;
                    this.y += dy * this.ease;
                }
            }

            draw() {
                // Vẽ hạt hình trái tim nhỏ hoặc chấm tròn
                ctx.fillStyle = this.color;
                // Vẽ trái tim nhỏ (dùng text cho đơn giản & nhẹ)
                // Hoặc vẽ hình tròn để tối ưu hiệu năng nếu quá lag
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- 3. HÀM XỬ LÝ TEXT & HÌNH ẢNH THÀNH TỌA ĐỘ ---
        
        // Hàm random màu sắc
        function getRandomColor() {
            const r = Math.floor(Math.random() * 255);
            const g = Math.floor(Math.random() * 255);
            const b = Math.floor(Math.random() * 255);
            return `rgb(${r},${g},${b})`;
        }

        // Hàm random chuỗi từ danh sách
        function getRandomMatrixText() {
            return matrixChars[Math.floor(Math.random() * matrixChars.length)];
        }

        function resize() {
            // Đảm bảo width/height luôn > 0 để tránh lỗi getImageData
            width = window.innerWidth || document.documentElement.clientWidth || 800;
            height = window.innerHeight || document.documentElement.clientHeight || 600;
            
            canvas.width = width;
            canvas.height = height;
            bufferCanvas.width = width;
            bufferCanvas.height = height;
            
            // Reset Matrix Columns
            const columnsCount = Math.floor(width / FONT_SIZE);
            const rowsCount = Math.floor(height / FONT_SIZE);
            
            matrixColumns = [];
            for (let i = 0; i < columnsCount; i++) {
                matrixColumns.push({
                    y: Math.floor(Math.random() * rowsCount), // Random vị trí trên màn hình
                    text: getRandomMatrixText(),
                    color: getRandomColor(),
                    drawIndex: 0 // Bắt đầu vẽ từ chữ đầu tiên
                });
            }
        }

        // Hàm lấy tọa độ pixel từ Text hoặc Hình
        function getPixels(text, isHeartShape = false) {
            // Kiểm tra an toàn trước khi gọi getImageData
            if (width <= 0 || height <= 0) return [];

            bufferCtx.clearRect(0, 0, width, height);
            bufferCtx.fillStyle = '#fff';
            bufferCtx.textAlign = 'center';
            bufferCtx.textBaseline = 'middle';

            if (isHeartShape) {
                // Vẽ trái tim lớn
                // Giới hạn kích thước font để không vượt quá màn hình
                const fontSize = Math.min(width, height) * 0.5;
                bufferCtx.font = `${fontSize}px serif`; 
                bufferCtx.fillText('❤', width / 2, height / 2);
            } else {
                // Vẽ chữ
                // Tự động điều chỉnh font size theo độ dài chữ
                let fontSize = 80;
                if (width < 600) fontSize = 40;
                if (text.length > 15) fontSize = width < 600 ? 30 : 60;
                
                bufferCtx.font = `bold ${fontSize}px "Share Tech Mono"`;
                bufferCtx.fillText(text, width / 2, height / 2);
            }

            // Quét dữ liệu pixel
            try {
                const imageData = bufferCtx.getImageData(0, 0, width, height);
                const data = imageData.data;
                const points = [];
                
                // Bước nhảy (step) để không lấy quá nhiều điểm gây lag
                const step = isHeartShape ? 8 : 4; 

                for (let y = 0; y < height; y += step) {
                    for (let x = 0; x < width; x += step) {
                        const index = (y * width + x) * 4;
                        // Nếu pixel có màu (alpha > 128)
                        if (data[index + 3] > 128) {
                            points.push({ x: x, y: y });
                        }
                    }
                }
                return points;
            } catch (e) {
                console.error("Lỗi quét pixel:", e);
                return [];
            }
        }

        // Gán tọa độ mục tiêu cho các hạt
        function setTargets(points) {
            if (points.length === 0) return;

            // Shuffle points để hiệu ứng bay ngẫu nhiên đẹp hơn
            points.sort(() => Math.random() - 0.5);

            for (let i = 0; i < particles.length; i++) {
                if (i < points.length) {
                    particles[i].targetX = points[i].x;
                    particles[i].targetY = points[i].y;
                    particles[i].color = '#ffffff';
                } else {
                    // Nếu thừa hạt, cho về tâm hoặc ẩn đi
                    particles[i].targetX = width / 2;
                    particles[i].targetY = height / 2;
                    particles[i].color = 'transparent'; // Ẩn hạt thừa
                }
            }
        }

        // Tạo lực nổ ngẫu nhiên
        function explodeParticles() {
            for (let p of particles) {
                // Random hướng nổ
                const angle = Math.random() * Math.PI * 2;
                const force = Math.random() * 15 + 5; // Tốc độ nổ
                p.vx = Math.cos(angle) * force;
                p.vy = Math.sin(angle) * force;
            }
        }

        // --- 4. LOGIC CHUYỂN CẢNH (SEQUENCER) ---

        function init() {
            resize();
            
            // Chờ cho đến khi kích thước cửa sổ hợp lệ (tránh lỗi width=0)
            if (width === 0 || height === 0) {
                requestAnimationFrame(init);
                return;
            }

            // Tạo pool particles
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(new Particle());
            }

            // Bắt đầu bằng hình trái tim
            const heartPoints = getPixels('', true);
            setTargets(heartPoints);

            // Bắt đầu loop vẽ
            animate();
        }

        function startSequence() {
            uiHint.style.display = 'none'; // Ẩn gợi ý
            
            // Bắt đầu chu trình
            runPhraseCycle();
        }

        function runPhraseCycle() {
            // 1. Nổ (Explode)
            state = 'EXPLODING';
            explodeParticles();

            // 2. Lơ lửng 1 giây (Hover)
            setTimeout(() => {
                state = 'HOVERING';
                
                // Chuẩn bị form chữ
                const text = PHRASES[currentPhraseIndex];
                const textPoints = getPixels(text, false);
                setTargets(textPoints);

                // Sau 1 giây lơ lửng -> Bắt đầu tụ lại (Forming)
                setTimeout(() => {
                    state = 'FORMING';
                    
                    // Sau khi tụ lại xong (khoảng 1s animation), chuyển sang Holding
                    setTimeout(() => {
                        state = 'HOLDING';
                        
                        // Giữ chữ trong 2 giây rồi xử lý tiếp
                        setTimeout(() => {
                            currentPhraseIndex++;
                            
                            // NẾU ĐÃ HẾT LIST -> QUAY VỀ TRÁI TIM
                            if (currentPhraseIndex >= PHRASES.length) {
                                returnToHeart();
                            } else {
                                runPhraseCycle(); // Tiếp tục câu tiếp theo
                            }
                        }, 2000); // Thời gian đọc chữ
                        
                    }, 1000); // Thời gian bay về vị trí
                }, 1000); // Thời gian lơ lửng
            }, 500); // Thời gian nổ mạnh
        }

        // Hàm đưa các hạt về lại hình trái tim ban đầu
        function returnToHeart() {
            // 1. Nổ tung câu cuối cùng
            state = 'EXPLODING';
            explodeParticles();

            // 2. Lơ lửng
            setTimeout(() => {
                state = 'HOVERING';
                
                // Lấy tọa độ hình trái tim
                const heartPoints = getPixels('', true);
                setTargets(heartPoints);
                
                // 3. Bay về hình trái tim (Chuyển về trạng thái WAITING)
                setTimeout(() => {
                    state = 'WAITING';
                    currentPhraseIndex = 0; // Reset index về 0
                    
                    // Hiện lại dòng hướng dẫn sau khi trái tim đã tụ lại
                    setTimeout(() => {
                        uiHint.style.display = 'block';
                    }, 1000);
                    
                }, 1000);
            }, 500);
        }

        // --- 5. RENDER LOOP ---

        function drawMatrix() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; // Xóa mờ tạo đuôi
            ctx.fillRect(0, 0, width, height);

            ctx.font = FONT_SIZE + 'px monospace'; // Sử dụng FONT_SIZE đã định nghĩa

            // Duyệt qua từng cột mưa
            const rowsCount = Math.floor(height / FONT_SIZE);

            for (let i = 0; i < matrixColumns.length; i++) {
                const col = matrixColumns[i];
                
                // Thiết lập màu sắc cố định cho cột này
                ctx.fillStyle = col.color;

                // CHỈ VẼ KHI ĐANG Ở TRONG MÀN HÌNH (y >= 0)
                // Thay đổi logic: Lặp lại ký tự (modulo) để dòng chữ dài đến tận đáy
                if (col.y >= 0) {
                    const charIndex = col.drawIndex % col.text.length;
                    const charToDraw = col.text.charAt(charIndex);
                    const yPos = col.y * FONT_SIZE;
                    ctx.fillText(charToDraw, i * FONT_SIZE, yPos);
                }

                // Tăng vị trí rơi
                col.y++;
                
                // Nếu đang ở trong vùng màn hình (y >= 0), thì tăng index chữ để lần sau vẽ chữ tiếp theo
                if (col.y >= 0) {
                    col.drawIndex++;
                }

                // KIỂM TRA RESET: Khi rơi quá màn hình (cộng thêm buffer để chắc chắn đã khuất hẳn)
                if (col.y > rowsCount + 5) {
                    // Reset về phía trên màn hình (vị trí âm ngẫu nhiên để rơi so le)
                    col.y = -Math.floor(Math.random() * 30); 
                    
                    // Reset lại bộ đếm chữ
                    col.drawIndex = 0;
                    
                    // Chọn cụm từ mới và màu mới
                    col.text = getRandomMatrixText(); 
                    col.color = getRandomColor(); 
                }
            }
        }

        function animate() {
            // Vẽ nền Matrix trước
            drawMatrix();

            // Vẽ Particles đè lên
            for (let p of particles) {
                p.update();
                p.draw();
            }

            requestAnimationFrame(animate);
        }

        // --- SỰ KIỆN ---
        window.addEventListener('resize', () => {
            resize();
            // Nếu đang ở trạng thái Waiting (Trái tim), tính lại vị trí
            if (state === 'WAITING' && width > 0 && height > 0) {
                const heartPoints = getPixels('', true);
                setTargets(heartPoints);
            }
        });

        canvas.addEventListener('click', () => {
            if (state === 'WAITING') {
                startSequence();
            }
        });

        // Đảm bảo DOM đã load hoàn toàn trước khi init
        window.onload = init;

    </script>
</body>
</html>